import * as R from 'ramda';

import { FileGenerator } from './file-generator';
import {
  DataType,
  ModelProperty,
} from '../interfaces/model-property.interface';
import { GeneratorParams } from '../interfaces/generator-param.interface';

export class NewInputGenerator extends FileGenerator {
  constructor(params: GeneratorParams) {
    super(params);

    this.suffix = 'input';
    this.models = params.models;
    this.output += this.writeNewInputClass();
    this.output = this.writeEnumDependencies() + this.output;
    this.output = this.writeGqlDependencies() + this.output;
  }

  public async generateFile(ifReplace: boolean) {
    await this.writeFile('dto/new-' + this.moduleName, ifReplace);
  }

  private writeGqlDependencies(): string {
    const { gqlTypes } = this;
    const gqlTypeStr = [...new Set(gqlTypes)].join(', ');
    if (gqlTypeStr.length) {
      return `import { Field, InputType, ${gqlTypeStr} } from '@nestjs/graphql';\n\n`;
    } else {
      return `import { Field, InputType } from '@nestjs/graphql';\n\n`;
    }
  }

  private writeEnumDependencies(): string {
    const { enumRelations } = this;
    if (!enumRelations.length) {
      return '';
    }

    const enumStr = enumRelations.join(', ');
    return `import { ${enumStr} } from '@prisma/client';\n\n`;
  }

  private writeNewInputClass(): string {
    const { properties } = this;

    let output = `import { Edit${this.className}Input } from './edit-${this.moduleName}.input';\n\n`;
    output += `@InputType({\n  description: '',\n})\n`;
    output += `export class New${this.className}Input extends Edit${this.className}Input {\n`;

    this.enumRelations = [];
    this.gqlTypes = [];

    for (const property of properties) {
      output += this.writeField(property);
    }

    output = R.dropLast(1, output);
    output += '}\n';
    return output;
  }

  private writeField(property: ModelProperty): string {
    const { key, type, gqlType, tsType, isArray, autoGenerated, nullable } =
      property;

    if (
      R.includes(key, [
        'id',
        'createdAt',
        'updatedAt',
        'deletedAt',
        'creatorId',
        'modifierId',
      ]) ||
      autoGenerated ||
      type === DataType.Relation ||
      nullable
    ) {
      return '';
    }

    if (type === DataType.Enum) {
      this.enumRelations.push(gqlType);
    }

    if (gqlType === 'Int' || gqlType === 'Float') {
      this.gqlTypes.push(gqlType);
    }

    const gqlTypeStr = isArray ? `[${gqlType}]` : gqlType;
    const keyNameStr = key;
    let tsTypeStr = tsType;

    if (isArray) {
      tsTypeStr = `${tsType}[]`;
    } else {
      tsTypeStr = `${tsType}`;
    }

    const output = `  @Field(() => ${gqlTypeStr}, {\n    description: 'Params Required For Creating ${this.modelName}',\n  })\n  ${keyNameStr}: ${tsTypeStr};\n\n`;

    return output;
  }
}
